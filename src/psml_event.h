/**
    #define meta ...
    printf("%s\n", meta);
**/


/*
	All rights reserved to Alireza Poshtkohi (c) 1999-2023.
	Email: arp@poshtkohi.info
	Website: http://www.poshtkohi.info
*/

#ifndef __Parvicursor_psml_psml_event_h__
#define __Parvicursor_psml_psml_event_h__

#include <general.h>
#include <System/BasicTypes/BasicTypes.h>
#include <System/Object/Object.h>
#include <System/String/String.h>
#include <System/Guid/Guid.h>
#include <System/ObjectDisposedException/ObjectDisposedException.h>
#include <System/ArgumentException/ArgumentOutOfRangeException.h>
#include <System/ArgumentException/ArgumentNullException.h>
#include <System/InvalidOperationException/InvalidOperationException.h>
#include <../Samples/LockFree/LockFree/LockFreeCounter/LockFreeCounter.h>

#include "psml_process.h"
#include "psml_time.h"

#include <iostream>
#include <vector>
#include <map>

using namespace System;
using namespace LockFree;

using namespace std;

//**************************************************************************************************************//

namespace Parvicursor
{
	namespace psml
	{
		//----------------------------------------------------
		// The type of events generated by PSML language through PSML framework and transmitted by PDES layer.
		enum psml_event_type
		{
			__UNKNOWN_EVENT = 0,											// An unknown event.
			__WAIT_SELF_EVENT = 1,											// Self timed events produced by psml_wait::wait(t)
			__PSML_EVENT = 2,												// An instance
			__DATA_UPDATE_FOR_NONE_SHARED_INTERFACE_EVENT = 3,				//
			__UPDATE_ACTIVATE_FOR_NONE_SHARED_INTERFACE_EVENT = 4,			//
			__RMI_PARAM_UPDATE_FOR_SHARED_INTERFACE_EVENT = 5,
			__RMI_PARAM_UPDATE_ACTIVATE_FOR_SHARED_INTERFACE_EVENT = 6,		//
			__CLOCK_SELF_EVENT = 7,										    //
			__INITIALIZATION_SELF_EVENT = 8,                                //
			__PSML_NULL_MESSAGE = 9,                                        //
		};

		// Forward declarations.
		class psml_simulator;
		class psml_pdes_event;
		//class psml_clock;

		// Currently, psml_event only supports statically instantiated events at compile time.
		// In future, dynamic instantiation will be added. In this case, we must make use of the
		// C++ STL map container for dynamic events becuase of the registeration search time.
		// Vector must only be used for static events. With both map and vector, iterating through
		// the entire collection is O(N). however (like list vs vector) vector stores elements
		// contiguously, so accessing the next element is much cheaper because it will use cache
		// optimally, whereas the map won't.
		class psml_event : public Object
		{
			friend class psml_simulator;
			friend class psml_pdes_lp;
			//friend class psml_clock;
			/*---------------------fields-----------------*/
			private: bool _isStatic;
			private: bool _has_added_to_static_events;
			private: UInt64 _eventID;
			private: static vector<psml_event *> *__static_events;
			private: std::vector<psml_process *> _initiators;
			private: std::vector<psml_process *> _subscribers;
			// The name of the psml_event instance.
			private: String _objName;
			// This atomic counter is used to generate event ID numbers. Take it to account that
			// on 32-bit machines the counter precision is Int32. Therefor, if this class is
		    // aimed to support dynamically allocated psml_events, the counter must be modified
		    // to atomically generate 64-bit values based on CAS.
			private: static LockFreeCounter __event_counter;
			/*---------------------methods----------------*/
			/// psml_event Class constructor.
			public: psml_event(const String &name = "", bool isStatic = true);
			/// psml_event Class destructor.
			public: ~psml_event();
			// Gets the name of the psml_event instance.
			public: const String &GetName();
			// Registers a process as an initiator who will begin the event notifications.
			public: void register_initiator(psml_process *p);
			// Registers a process as a subscriber which will receive the event notifications.
			public: void register_subscriber(psml_process *p);
			public: void register_initiator(psml_process &p);
			public: void register_subscriber(psml_process &p);
			public: void notify(psml_process *issuer);
			public: void notify(const psml_time &delay, psml_process *issuer);
			public: void notify(double delay, psml_time_unit tu, psml_process *issuer);
			private: void notify_internal(UInt64 delay, psml_process *issuer);
			/*--------------------------------------------*/

		};
		//----------------------------------------------------
	}
};
//**************************************************************************************************************//

#endif

